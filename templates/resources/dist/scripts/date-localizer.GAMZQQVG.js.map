{
  "version": 3,
  "sources": ["../../src/scripts/theme/utils/init.js", "../../src/scripts/packs/date-localizer.js"],
  "sourcesContent": ["// This script establishes a MutationObserver to detect changes in the DOM and run callbacks when changes are detected.\n// It tries to be efficient about this by establishing only one obeserver and running all callbacks once on each new node.\n// There is a limitation of this mechanism: if a node contains a script that has not before been added to the dom,\n// and it calls onDomChange, its callback won't be run against anything until the next mutation.\n// To work around this, ensure the script is loaded in the initial page load or a previous fetch.\n\nwindow.StoreConnect = window.StoreConnect || {}\nwindow.StoreConnect.ObserverCallbacks = window.StoreConnect.ObserverCallbacks || []\n\ndocument.addEventListener('DOMContentLoaded', establishObserver)\n\nexport function onDomChange(initCallback) {\n  window.StoreConnect.ObserverCallbacks.push(initCallback)\n}\n\nfunction establishObserver() {\n  if (window.StoreConnect.Observer) return\n\n  window.StoreConnect.Observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      mutation.addedNodes.forEach((node) => {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          runCallbacks(node, 'mutation')\n        }\n      })\n    })\n  })\n\n  window.StoreConnect.Observer.observe(document.body, { childList: true, subtree: true })\n\n  runCallbacks(document, 'initial load')\n}\n\nfunction runCallbacks(node, _context) {\n  window.StoreConnect.ObserverCallbacks.forEach((callback) => callback(node))\n}\n", "import { onDomChange } from '../theme/utils/init'\n\nonDomChange(init)\n\nfunction init(node) {\n  ;[...node.querySelectorAll('time[data-timestamp]')].forEach((elem) => localize(elem))\n}\n\nfunction localize(elem) {\n  const styles = ['full', 'long', 'medium', 'short']\n  const timestamp = elem.getAttribute('data-timestamp')\n\n  if (!timestamp || timestamp === '') return\n\n  let format = {}\n\n  let dateStyle = elem.getAttribute('data-date-style')\n  if (styles.includes(dateStyle)) format['dateStyle'] = dateStyle\n\n  let timeStyle = elem.getAttribute('data-time-style')\n  if (styles.includes(timeStyle)) format['timeStyle'] = timeStyle\n\n  const formatter = new Intl.DateTimeFormat(Intl.DateTimeFormat().resolvedOptions().locale, format)\n  outputString = formatter.format(Date.parse(timestamp))\n\n  elem.innerHTML = outputString\n\n  elem.setAttribute('title', Intl.DateTimeFormat().resolvedOptions().timeZone)\n}\n"],
  "mappings": ";;AAMA,SAAO,eAAe,OAAO,gBAAgB,CAAC;AAC9C,SAAO,aAAa,oBAAoB,OAAO,aAAa,qBAAqB,CAAC;AAElF,WAAS,iBAAiB,oBAAoB,iBAAiB;AAExD,WAAS,YAAY,cAAc;AACxC,WAAO,aAAa,kBAAkB,KAAK,YAAY;AAAA,EACzD;AAEA,WAAS,oBAAoB;AAC3B,QAAI,OAAO,aAAa,SAAU;AAElC,WAAO,aAAa,WAAW,IAAI,iBAAiB,CAAC,cAAc;AACjE,gBAAU,QAAQ,CAAC,aAAa;AAC9B,iBAAS,WAAW,QAAQ,CAAC,SAAS;AACpC,cAAI,KAAK,aAAa,KAAK,cAAc;AACvC,yBAAa,MAAM,UAAU;AAAA,UAC/B;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAED,WAAO,aAAa,SAAS,QAAQ,SAAS,MAAM,EAAE,WAAW,MAAM,SAAS,KAAK,CAAC;AAEtF,iBAAa,UAAU,cAAc;AAAA,EACvC;AAEA,WAAS,aAAa,MAAM,UAAU;AACpC,WAAO,aAAa,kBAAkB,QAAQ,CAAC,aAAa,SAAS,IAAI,CAAC;AAAA,EAC5E;;;ACjCA,cAAY,IAAI;AAEhB,WAAS,KAAK,MAAM;AAClB;AAAC,KAAC,GAAG,KAAK,iBAAiB,sBAAsB,CAAC,EAAE,QAAQ,CAAC,SAAS,SAAS,IAAI,CAAC;AAAA,EACtF;AAEA,WAAS,SAAS,MAAM;AACtB,UAAM,SAAS,CAAC,QAAQ,QAAQ,UAAU,OAAO;AACjD,UAAM,YAAY,KAAK,aAAa,gBAAgB;AAEpD,QAAI,CAAC,aAAa,cAAc,GAAI;AAEpC,QAAI,SAAS,CAAC;AAEd,QAAI,YAAY,KAAK,aAAa,iBAAiB;AACnD,QAAI,OAAO,SAAS,SAAS,EAAG,QAAO,WAAW,IAAI;AAEtD,QAAI,YAAY,KAAK,aAAa,iBAAiB;AACnD,QAAI,OAAO,SAAS,SAAS,EAAG,QAAO,WAAW,IAAI;AAEtD,UAAM,YAAY,IAAI,KAAK,eAAe,KAAK,eAAe,EAAE,gBAAgB,EAAE,QAAQ,MAAM;AAChG,mBAAe,UAAU,OAAO,KAAK,MAAM,SAAS,CAAC;AAErD,SAAK,YAAY;AAEjB,SAAK,aAAa,SAAS,KAAK,eAAe,EAAE,gBAAgB,EAAE,QAAQ;AAAA,EAC7E;",
  "names": []
}
