{
  "version": 3,
  "sources": ["../../src/scripts/theme/utils/init.js", "../../src/scripts/packs/fulfilment.js"],
  "sourcesContent": ["// This script establishes a MutationObserver to detect changes in the DOM and run callbacks when changes are detected.\n// It tries to be efficient about this by establishing only one obeserver and running all callbacks once on each new node.\n// There is a limitation of this mechanism: if a node contains a script that has not before been added to the dom,\n// and it calls onDomChange, its callback won't be run against anything until the next mutation.\n// To work around this, ensure the script is loaded in the initial page load or a previous fetch.\n\nwindow.StoreConnect = window.StoreConnect || {}\nwindow.StoreConnect.ObserverCallbacks = window.StoreConnect.ObserverCallbacks || []\n\ndocument.addEventListener('DOMContentLoaded', establishObserver)\n\nexport function onDomChange(initCallback) {\n  window.StoreConnect.ObserverCallbacks.push(initCallback)\n}\n\nfunction establishObserver() {\n  if (window.StoreConnect.Observer) return\n\n  window.StoreConnect.Observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      mutation.addedNodes.forEach((node) => {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n          runCallbacks(node, 'mutation')\n        }\n      })\n    })\n  })\n\n  window.StoreConnect.Observer.observe(document.body, { childList: true, subtree: true })\n\n  runCallbacks(document, 'initial load')\n}\n\nfunction runCallbacks(node, _context) {\n  window.StoreConnect.ObserverCallbacks.forEach((callback) => callback(node))\n}\n", "import { onDomChange } from '../theme/utils/init'\n\nwindow.StoreConnectUI = window.StoreConnectUI || {}\n\nwindow.StoreConnectUI.Fulfilment = (function () {\n  let prevSubset\n\n  onDomChange(init)\n\n  function init(node) {\n    ;[...node.querySelectorAll('[data-fulfilment-option-trigger]')].forEach((trigger) =>\n      trigger.addEventListener('click', choose)\n    )\n  }\n\n  function choose(event) {\n    const choice = event.currentTarget.parentNode\n    const subset = choice.querySelector('[data-fulfilment-option-subset]')\n\n    // We manually handle checking inputs\n    // to avoid multiple events firing\n    event.preventDefault()\n\n    // If there is a previously opened subset of options\n    // we close it when a new choice is made\n    if (prevSubset && !prevSubset.contains(choice)) {\n      close(prevSubset)\n    }\n\n    // If our chosen option has a subset of options we\n    // open the subset. Otherwise, we select the option.\n    subset ? open(subset) : select(choice)\n\n    enableSubmitButton()\n  }\n\n  function select(option) {\n    ;[...document.querySelectorAll('[data-fulfilment-option]')].map((option) =>\n      option.classList.remove('is-selected')\n    )\n    option.classList.add('is-selected')\n    option.querySelector('input[type=radio]').checked = true\n  }\n\n  function close(subset) {\n    subset.classList.remove('is-active')\n    subset.parentNode.classList.remove('is-active')\n  }\n\n  function open(subset) {\n    subset.classList.add('is-active')\n    subset.parentNode.classList.add('is-active')\n    prevSubset = subset\n  }\n\n  function enableSubmitButton() {\n    const button = document.querySelector('[data-fulfilment-button]')\n    const form = button.closest('form')\n\n    if (form.checkValidity() && !form.querySelector('[data-pending]')) {\n      document.querySelector('[data-fulfilment-button]').removeAttribute('disabled')\n    }\n  }\n})()\n"],
  "mappings": ";;AAMA,SAAO,eAAe,OAAO,gBAAgB,CAAC;AAC9C,SAAO,aAAa,oBAAoB,OAAO,aAAa,qBAAqB,CAAC;AAElF,WAAS,iBAAiB,oBAAoB,iBAAiB;AAExD,WAAS,YAAY,cAAc;AACxC,WAAO,aAAa,kBAAkB,KAAK,YAAY;AAAA,EACzD;AAEA,WAAS,oBAAoB;AAC3B,QAAI,OAAO,aAAa,SAAU;AAElC,WAAO,aAAa,WAAW,IAAI,iBAAiB,CAAC,cAAc;AACjE,gBAAU,QAAQ,CAAC,aAAa;AAC9B,iBAAS,WAAW,QAAQ,CAAC,SAAS;AACpC,cAAI,KAAK,aAAa,KAAK,cAAc;AACvC,yBAAa,MAAM,UAAU;AAAA,UAC/B;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAED,WAAO,aAAa,SAAS,QAAQ,SAAS,MAAM,EAAE,WAAW,MAAM,SAAS,KAAK,CAAC;AAEtF,iBAAa,UAAU,cAAc;AAAA,EACvC;AAEA,WAAS,aAAa,MAAM,UAAU;AACpC,WAAO,aAAa,kBAAkB,QAAQ,CAAC,aAAa,SAAS,IAAI,CAAC;AAAA,EAC5E;;;ACjCA,SAAO,iBAAiB,OAAO,kBAAkB,CAAC;AAElD,SAAO,eAAe,aAAc,WAAY;AAC9C,QAAI;AAEJ,gBAAY,IAAI;AAEhB,aAAS,KAAK,MAAM;AAClB;AAAC,OAAC,GAAG,KAAK,iBAAiB,kCAAkC,CAAC,EAAE;AAAA,QAAQ,CAAC,YACvE,QAAQ,iBAAiB,SAAS,MAAM;AAAA,MAC1C;AAAA,IACF;AAEA,aAAS,OAAO,OAAO;AACrB,YAAM,SAAS,MAAM,cAAc;AACnC,YAAM,SAAS,OAAO,cAAc,iCAAiC;AAIrE,YAAM,eAAe;AAIrB,UAAI,cAAc,CAAC,WAAW,SAAS,MAAM,GAAG;AAC9C,cAAM,UAAU;AAAA,MAClB;AAIA,eAAS,KAAK,MAAM,IAAI,OAAO,MAAM;AAErC,yBAAmB;AAAA,IACrB;AAEA,aAAS,OAAO,QAAQ;AACtB;AAAC,OAAC,GAAG,SAAS,iBAAiB,0BAA0B,CAAC,EAAE;AAAA,QAAI,CAACA,YAC/DA,QAAO,UAAU,OAAO,aAAa;AAAA,MACvC;AACA,aAAO,UAAU,IAAI,aAAa;AAClC,aAAO,cAAc,mBAAmB,EAAE,UAAU;AAAA,IACtD;AAEA,aAAS,MAAM,QAAQ;AACrB,aAAO,UAAU,OAAO,WAAW;AACnC,aAAO,WAAW,UAAU,OAAO,WAAW;AAAA,IAChD;AAEA,aAAS,KAAK,QAAQ;AACpB,aAAO,UAAU,IAAI,WAAW;AAChC,aAAO,WAAW,UAAU,IAAI,WAAW;AAC3C,mBAAa;AAAA,IACf;AAEA,aAAS,qBAAqB;AAC5B,YAAM,SAAS,SAAS,cAAc,0BAA0B;AAChE,YAAM,OAAO,OAAO,QAAQ,MAAM;AAElC,UAAI,KAAK,cAAc,KAAK,CAAC,KAAK,cAAc,gBAAgB,GAAG;AACjE,iBAAS,cAAc,0BAA0B,EAAE,gBAAgB,UAAU;AAAA,MAC/E;AAAA,IACF;AAAA,EACF,EAAG;",
  "names": ["option"]
}
